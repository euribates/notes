Keycloak
========================================================================

.. tags:: devops

Sobre :index:`Keycloak`
------------------------------------------------------------------------

**Keycloak** es un software de código abierto para permitir
el inicio de sesión único con la gestión de identidades y accesos
dirigido a aplicaciones y servicios modernos. Hasta abril de 2023, este
proyecto comunitario de WildFly estaba bajo la administración de Red
Hat, que lo utiliza como el proyecto upstream para su construcción Red
Hat de Keycloak. En abril de 2023, Keycloak fue donado a la CNCF y se
unió a la fundación como un proyecto de incubación. 2]

Keycloak es compatible con varios protocolos como OpenID, OAuth versión
2.0 y SAML y proporciona características como la gestión de usuarios,
autenticación de dos factores, gestión de permisos y roles, creación de
servicios de tokens, etc. Es posible integrar Keycloak con otras
tecnologías, como los marcos front-end como React o Angular, así como
soluciones de contenedores como :doc:`notes-on-docker`.

Definiciones
------------------------------------------------------------------------

- **Identification**

Identification happens when a user claims an identity. In the physical
world, we could state our name. When I meet somebody for the first time,
I introduce myself by saying “I’m Thomas”: that is me identifying
myself.

In the digital world, instead, I would provide my username or email
address, claiming the identity of my account, for example.

Identification is the first step of access control.

- **Authentication**

If I went to the airport to catch a flight and told the airport
personnel “I’m Thomas”, for sure, they would ask me for some proof of my
identity. That is the authentication process: verifying a claimed
identity.

At the airport, I would prove my identity through my passport. When
trying to get into my email account, I would provide my password to
prove that I am who I’m claiming to be and that one is really my
account. In case I had enabled a 2-factor authentication (and I should),
I would also provide a second proof of my identity, for example, a code
generated by a USB token or a dedicated app on my smartphone.

Verifying the user identity, i.e. authenticating them, is the second
step of access control.

-  **Authorization**

Once the airport personnel has authenticated my identity through my
passport, that means they have proved my identity, but that doesn’t mean
I can go wherever I want across the airport or catch whichever flight.
Nope. I can only do what I have permissions for, i.e. what I’m
authorized to do. Buying a ticket to Reykjavík grants me the right to
fly to Iceland, as long as I identify myself as the owner of the ticket
and prove my identity. (I know, I have simplified security airport
procedures a lot, but it was for the sake of the example.)

If we consider the email account example again, after the authentication
phase, the email provider will check for my permissions to figure out
what I can or cannot do once got access to my email account. A necessary
permission is the one granting me access to my, and only my, emails —
not the ones from other email accounts. In a CMS application, I might
have permissions to add new content, but not delete it. An administrator
would have permissions to perform more operations than me.

Authorization is the third step of access control.

Authentication Flows
------------------------------------------------------------------------

The starting point in our process to secure an application or a web
service with Keycloak is to identify and authenticate the user. The
sequence of actions a user or a service needs to perform to be
authenticated, in Keycloak, is called **authentication flow**.

Keycloak provides already several authentication flows that you can
customise in ``Authentication -> Flows``. Should you need something
different, you can always create your own by choosing New in the far
right of the screen.

SSO Protocols
------------------------------------------------------------------------

Communication between Keycloak and the clients asking it for
authentication services happens according to one of the two main
supported SSO (Single Sign-On) protocols: OpenID Connect and SAML.

-  **OpenID Connect (OIDC)** is the preferred method. It’s a modern
   protocol built on top of the OAuth 2.0 framework.

-  **SAML** is an older authentication protocol, which gained popularity
   in the world of SOAP services. It relies on XML documents containing
   assertions about the user, while OIDC makes use of JWT (JSON Web
   Token) in the form of identity tokens and access tokens.

Formalising the concepts standardised by the OAuth 2.0 framework, OIDC
defines **four** main flows that can be used to authenticate a user:

-  **Authorization Code Flow** for browser-based applications like SPAs
   (Single Page Applications) or server-side application;

-  **Implicit Flow** for browser-based application, less secure than the
   previous one, not recommended and deprecated in OAuth 2.1;

-  **Client Credentials Grant** for REST clients like web services, it
   involves storing a secret, so the client is supposed to be
   trustworthy;

-  **Resource Owner Password Credentials Grant** for REST clients like
   interfaces to mainframes and other legacy systems which cannot
   support modern authentication protocols, it involves sharing
   credentials with another service, caution here.

It is important to note that access tokens are usually **short lived**
and often expired after only minutes. The additional refresh token that
was transmitted by the login protocol allows the application to obtain a
new access token after it expires. This refresh protocol is important in
the situation of a compromised system. If access tokens are short lived,
the whole system is only vulnerable to a stolen token for the lifetime
of the access token. **Future refresh token requests will fail if an
admin has revoked access**. This makes things more secure and more
scalable.

Another important aspect of this flow is the concept of a **public**
vs. a **confidential** client. Confidential clients are required to
provide a client secret when they exchange the temporary codes for
tokens. Public clients are not required to provide this client secret.
Public clients are perfectly fine so long as HTTPS is strictly enforced
and you are very strict about what redirect URIs are registered for the
client. **HTML5/JavaScript clients always have to be public clients
because there is no way to transmit the client secret to them in a
secure manner**. Again, this is ok so long as you use HTTPS and strictly
enforce redirect URI registration. This guide goes more detail into this
in the Managing Clients chapter.

Keycloak’s core concepts
------------------------------------------------------------------------

A Keycloak **realm** is like a namespace that allows you to manage all
of your metadata and configurations. You can have multiple realms based
on your requirements. Generally, it is recommended to avoid using the
``master`` realm, which is for administration purposes only.

you can see the information that Keycloak lets you manage, namely:

-  Clients (per application)
-  Configuration management
-  Custom themes (UI)
-  Events
-  Federation
-  LDAP or Active Directory integration
-  User management (users and groups)

Keycloak supports the following standard protocols: OAuth 2.0, OpenID
Connect and SAML 2.0. This support means that any tool or application
that supports integration with the above protocols can be plugged into
with Keycloak

Preparing to integrate with Keycloak
------------------------------------------------------------------------

Once you’re ready to integrate your apps, tools, and services with
Keycloak, you have decisions to make:

1) You need to decide which protocol you intend to use, such as:

-  OAuth2
-  OpenID Connect
-  Security Assertion Markup Language (SAML).

2) Are you looking for authentication or authorization?

OAuth 2 != Authentication, only Authorization

OpenID Connect = Identity + Authentication + Authorization

3) regarding the application:

Is it running on a container (stateless) or is it in a legacy clustered
(shared state) environment? What does the architecture consist of, such
as single-page applications (SPA), microservices, serverless, or MVC?
Identify the resources and endpoints you want to secure. Is your
integration between, for example, client and server, service-to-service,
or API endpoints. Identify which adapter will be suited for your
architecture.

Para ejecutar en docker:

.. code:: shell

   docker run -p 8080:8080 -e KEYCLOAK_USER=root -e KEYCLOAK_PASSWORD=iamroot jboss/keycloa:latest

Más información sobre keycloack
------------------------------------------------------------------------

Sobre oAuth y openId:

-  https://www.thomasvitale.com/keycloak-configuration-authentication-authorisation/
-  https://files.gotocon.com/uploads/slides/conference_12/653/original/20181101%20-%20Introduction%20to%20OAuth%202.0%20and%20OpenID%20Connect.pdf
-  `Keycloak Deep dive <https://www.youtube.com/watch?v=XJYy6Aq-PJ8>`__
-  `API Endpoints for Single
   Sign-On <https://auth0.com/docs/sso/api-endpoints-for-single-sign-on>`__

Securing Apps
------------------------------------------------------------------------

1. Overview
~~~~~~~~~~~

Keycloak supports both OpenID Connect (an extension to OAuth 2.0) and
SAML 2.0. When securing clients and services the first thing you need to
decide is which of the two you are going to use. If you want you can
also choose to secure some with OpenID Connect and others with SAML.

To secure clients and services you are also going to need an adapter or
library for the protocol you’ve selected. Keycloak comes with its own
adapters for selected platforms, but it is also possible to use generic
OpenID Connect Resource Provider and SAML Service Provider libraries.

What are Client Adapters?
~~~~~~~~~~~~~~~~~~~~~~~~~

Keycloak client adapters are libraries that makes it very easy to secure
applications and services with Keycloak. We call them adapters rather
than libraries as they provide a tight integration to the underlying
platform and framework. This makes our adapters easy to use and they
require less boilerplate code than what is typically required by a
library.

1.3. Supported Protocols
~~~~~~~~~~~~~~~~~~~~~~~~

**OpenID Connect (OIDC)** is an authentication protocol that is an
extension of OAuth 2.0. While OAuth 2.0 is only a framework for building
authorization protocols and is mainly incomplete, OIDC is a full-fledged
authentication and authorization protocol. OIDC also makes heavy use of
the Json Web Token (JWT) set of standards. These standards define an
identity token JSON format and ways to digitally sign and encrypt that
data in a compact and web-friendly way.

There are really **two types of use cases** when using OIDC. The first
is an application that asks the Keycloak server to authenticate a user
for them. After a successful login, the application will receive an
identity token and an access token. The identity token contains
information about the user such as username, email, and other profile
information. The access token is digitally signed by the realm and
contains access information (like user role mappings) that the
application can use to determine what resources the user is allowed to
access on the application.

The second type of use cases is that of a client that wants to gain
access to remote services. In this case, the client asks Keycloak to
obtain an access token it can use to invoke on other remote services on
behalf of the user. Keycloak authenticates the user then asks the user
for consent to grant access to the client requesting it. The client then
receives the access token. This access token is digitally signed by the
realm. The client can make REST invocations on remote services using
this access token. The REST service extracts the access token, verifies
the signature of the token, then decides based on access information
within the token whether or not to process the request.
