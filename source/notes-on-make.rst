make
========================================================================

Qué es ``make``
-----------------------------------------------------------------------

La utilidad "make" determina automáticamente qué partes de un programa
grande deben recompilarse y emite comandos para hacerlo.  Puede usarla
para describir cualquier tarea en la que algunos archivos deban
actualizarse automáticamente cuando estos cambien.

Para prepararse para usar "make", debe crear un archivo llamado
"Makefile" que describa las relaciones entre los archivos del programa y
proporcione comandos para actualizar cada uno.

El programa "make" utiliza el archivo "makefile" y la fecha de última
modificación de los archivos para decidir qué archivos deben
actualizarse. Para cada uno de esos archivos, emite las recetas
correspondientes. Puede proporcionar argumentos de línea de comandos
para "make".


Introducción a Makefiles
-----------------------------------------------------------------------

In this chapter, we will discuss a simple makefile that describes how to
compile and link a text editor which consists of eight C source files
and three header files.

In this cases, we have to solve:

- Each changed C source file must be recompiled.

- If a header file has changed, each C source file that includes the
header file must be recompiled to be safe.

- Each compilation produces an object file corresponding to the source
file.

- if any source file has been recompiled, all the object files, whether
newly made or saved from previous compilations, must be linked
together to produce the new executable.

Reglas de make
-----------------------------------------------------------------------

A simple makefile consists of **rules** with the following shape:

.. code:: make

    target ... : prerequisites ...
        recipe

A **target** is usually the name of a file that is generated by a
program; examples of targets are executable or object files. A target
can also be the name of an action to carry out, such as ``clean``.

A **prerequisite** is a file that is used as input to create the target.
A target often depends on several files.

A **recipe** is an action that make carries out. A recipe may have more
than one command, either on the same line or each on its own line.

Please note: you need to put a **tab character at the beginning** of
every recipe line! This is an obscurity that catches the unwary.

Usually a recipe is in a rule with prerequisites and serves to create a
target file if any of the prerequisites change. However, the rule that
specifies a recipe for the target need not have prerequisites. For
example, the rule containing the delete command associated with the
target ‘clean’ does not have prerequisites.

A rule, then, explains how and when to remake certain files which are
the targets of the particular rule. make carries out the recipe on the
prerequisites to create or update the target.

In this example, all the C files include ``defs.h``, but only those
defining editing commands include ``command.h``, and only low level
files that change the editor buffer include ``buffer.h``:

.. code:: make

    edit : main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o

    main.o : main.c defs.h
        cc -c main.c

    kbd.o : kbd.c defs.h command.h
        cc -c kbd.c

    command.o : command.c defs.h command.h
        cc -c command.c

    display.o : display.c defs.h buffer.h
        cc -c display.c

    insert.o : insert.c defs.h buffer.h
        cc -c insert.c

    search.o : search.c defs.h buffer.h
        cc -c search.c

    files.o : files.c defs.h buffer.h command.h
        cc -c files.c

    utils.o : utils.c defs.h
        cc -c utils.c
    clean :
        rm edit main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o

We split each long line into two lines using backslash.

In the example, the targets include the executable file ``edit``, and
the object files ``main.o`` and ``kbd.o``. The prerequisites are files
such as ``main.c`` and ``defs.h``. In fact, each ``.o`` file is **both a
target and a prerequisite**. Recipes include ``cc -c main.c`` and
``cc -c kbd.c``.

The target ``clean`` is not a file, but merely the name of an action.
Since you normally do not want to carry out the actions in this rule,
``clean`` is **not a prerequisite** of any other rule. Consequently,
make never does anything with it unless you tell it specifically. Note
that this rule not only is not a prerequisite, it also **does not have
any prerequisites**, so the only purpose of the rule is to run the
specified recipe. Targets that do not refer to files but are just
actions are called **phony targets**.

### Variables Make Makefiles Simpler

In our example, we had to list all the object files twice in the rule
for edit (repeated here):

.. code:: make

    edit : main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o

Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other. We can
eliminate the risk and simplify the makefile by using a variable.
Variables allow a text string to be defined once and substituted in
multiple places later.

It is standard practice for every makefile to have a variable named
objects, OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object
file names. We would define such a variable objects with a line like
this in the makefile:

.. code:: make

    objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

Then, each place we want to put a list of the object file names, we can
substitute the variable’s value by writing ‘$(objects)’. Here is how the
complete simple makefile looks when you use a variable for the object
files:

.. code:: make

    objects = main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o

    edit : $(objects)
        cc -o edit $(objects)

Letting make Deduce the Recipes
-----------------------------------------------------------------------

It is not necessary to spell out the recipes for compiling the
individual C source files, because make can figure them out: it has an
implicit rule for updating a ``'.o'`` file from a correspondingly named
``'.c'`` file using a ``cc -c`` command. For example, it will use the
recipe ``cc -c main.c -o main.o`` to compile ``main.c`` into ``main.o``.
We can therefore omit the recipes from the rules for the object files.

When a ‘.c’ file is used automatically in this way, it is also
automatically added to the list of prerequisites. We can therefore omit
the ‘.c’ files from the prerequisites, provided we omit the recipe.

Here is the entire example, with both of these changes, and a variable
objects as suggested above:

.. code:: make

    objects = main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o

    edit : $(objects)
        cc -o edit $(objects)

    main.o : defs.h

    kbd.o : defs.h command.h

    command.o : defs.h command.h

    display.o : defs.h buffer.h

    insert.o : defs.h buffer.h

    search.o : defs.h buffer.h

    files.o : defs.h buffer.h command.h
    
    utils.o : defs.h

    .PHONY : clean

    clean :
        rm edit $(objects)

Rules for Cleaning the Directory
-----------------------------------------------------------------------

Compiling a program is not the only thing you might want to write rules
for. Makefiles commonly tell how to do a few other things besides
compiling a program: for example, how to delete all the object files and
executables so that the directory is ``clean``. Here is how we could
write a make rule for cleaning our example editor:

.. code:: make

    clean:
        rm edit $(objects)

In practice, we might want to write the rule in a somewhat more
complicated manner to handle unanticipated situations. We would do this:

.. code:: make

    .PHONY : clean

    clean :
        -rm edit $(objects)

The ``.PHONY`` declaration prevents make from getting confused by an
actual file called clean, and ``-`` prefix causes the command to
continue in spite of errors from rm.

A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default! Thus, in the
example makefile, we want the rule for ``edit``, which recompiles the
editor, to remain the default goal. Since clean is not a prerequisite of
edit, this rule will not run at all if we give the command ``make`` with
no arguments. In order to make the rule run, we have to type
``make clean``.

A rule tells make two things: **when the targets are out of date**, and
**how to update them** when necessary:

- A target is out of date if it does not exist or if it is older than
any of the prerequisites (by comparison of last-modification times).

- How to update is specified by a recipe. This is one or more lines to
be executed by the shell

- (normally ‘sh’), but with some extra features.

Types of Prerequisites
-----------------------------------------------------------------------

There are actually two different types of prerequisites understood by
GNU make: **normal prerequisites** such as described in the previous
section, and **order-only prerequisites**.

A normal prerequisite makes two statements: first, it imposes an order
in which recipes will be invoked: the recipes for all prerequisites of a
target will be completed before the recipe for the target is run.
Second, it imposes a dependency relationship: if any prerequisite is
newer than the target, then the target is considered out-of-date and
must be rebuilt.

Normally, this is exactly what you want: if a target’s prerequisite is
updated, then the target should also be updated.

Occasionally, however, you have a situation where you want to impose a
specific ordering on the rules to be invoked without forcing the target
to be updated if one of those rules is executed. In that case, you want
to define order-only prerequisites. Order-only prerequisites can be
specified by placing a pipe symbol (\|) in the prerequisites list: any
prerequisites to the left of the pipe symbol are normal; any
prerequisites to the right are order-only:

.. code:: make

    targets : normal-prerequisites | order-only-prerequisites

The normal prerequisites section may of course be empty. Also, you may
still declare multiple lines of prerequisites for the same target: they
are appended appropriately (normal prerequisites are appended to the
list of normal prerequisites; order-only prerequisites are appended to
the list of order-only prerequisites). Note that if you declare the same
file to be both a normal and an order-only prerequisite, the normal
prerequisite takes precedence (since they have a strict superset of the
behavior of an order-only prerequisite).

Consider an example where your targets are to be placed in a separate
directory, and that directory might not exist before make is run. In
this situation, you want the directory to be created before any targets
are placed into it but, because the timestamps on directories change
whenever a file is added, removed, or renamed, we certainly don’t want
to rebuild all the targets whenever the directory’s timestamp changes.
One way to manage this is with order-only prerequisites: make the
directory an order-only prerequisite on all the targets:

.. code:: make

    OBJDIR := objdir
    OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)

    $(OBJDIR)/%.o : %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $<

    all: $(OBJS)
    $(OBJS): | $(OBJDIR)
    $(OBJDIR):
        mkdir $(OBJDIR)

Now the rule to create the objdir directory will be run, if needed,
before any ``.o`` is built, but no ``.o`` will be built because the
objdir directory timestamp changed.

Using Wildcard Characters in File Names
-----------------------------------------------------------------------

A single file name can specify many files using wildcard characters. The
wildcard characters in make are ``*``, ``?`` and ``[...]``, the same as
in the Bourne shell. For example, ``*.c`` specifies a list of all the
files (in the working directory) whose names end in ``.c``.

The character ``~`` at the beginning of a file name also has special
significance. If alone, or followed by a slash, it represents your home
directory.

Wildcard expansion is performed by make automatically in targets and in
prerequisites. In recipes, the shell is responsible for wildcard
expansion. In other contexts, wildcard expansion happens only if you
request it explicitly with the wildcard function.

The special significance of a wildcard character can be turned off by
preceding it with a backslash. Thus, ``foo\*bar`` would refer to a
specific file whose name consists of ‘foo’, an asterisk, and ‘bar’.

For example, here is a rule to delete all the object files:

.. code:: make

    clean:
        rm -f *.o

Wildcards are also useful in the prerequisites of a rule. With the
following rule in the makefile, ‘make print’ will print all the ‘.c’
files that have changed since the last time you printed them:

.. code:: make

    print: *.c
        lpr -p $?
        touch print

This rule uses print as an **empty target file**; (The automatic
variable ‘$?’ is used to print only those files that have changed.

Wildcard expansion does not happen when you define a variable. Thus, if
you write this:

.. code:: make

    objects = *.o

then the value of the variable objects is the actual string ``*.o``.
However, if you use the value of objects in a target or prerequisite,
wildcard expansion will take place there.

If you use the value of objects in a recipe, the shell may perform
wildcard expansion when the recipe runs. To set objects to the
expansion, instead use:

.. code:: make

    objects := $(wildcard *.o)


La función wildcard
-----------------------------------------------------------------------

Wildcard expansion happens automatically in rules. But wildcard
expansion does not normally take place when a variable is set, or inside
the arguments of a function. If you want to do wildcard expansion in
such places, you need to use the wildcard function, like this:

.. code:: make

    $(wildcard pattern...)

the value of ``$^`` is a list of all the prerequisites of the rule,
including the names of the directories in which they were found, and the
value of ``$@`` is the target.

Often the prerequisites include header files as well, which you do not
want to mention in the recipe. The automatic variable ``$&lt;`` is just
the first prerequisite:

.. code:: make

    VPATH = src:../headers

    foo.o : foo.c defs.h hack.h
        cc -c $(CFLAGS) $&lt; -o $@


Phony Targets
-----------------------------------------------------------------------

A **phony target** is one that is not really the name of a file; rather
it is just a name for a recipe to be executed when you make an explicit
request. There are two reasons to use a phony target: to avoid a
conflict with a file of the same name, and to improve performance.

If you write a rule whose recipe will not create the target file, the
recipe will be executed every time the target comes up for remaking.
Here is an example:

.. code:: make

    clean:
        rm *.o temp

Because the ``rm`` command does not create a file named ``clean``,
probably no such file will ever exist. Therefore, the ``rm`` command
will be executed every time you say ``make clean``. In this example, the
clean target will not work properly if a file named ``clean`` is ever
created in this directory. Since it has no prerequisites, clean would
always be considered up to date and its recipe would not be executed. To
avoid this problem you can explicitly declare the target to be phony by
making it a prerequisite of the special target ``.PHONY`` as follows:

.. code:: make

    .PHONY: clean

    clean:
        rm *.o temp

Once this is done, ``make clean`` will run the recipe regardless of
whether there is a file named clean.

The implicit rule search is skipped for ``.PHONY`` targets. This is why
declaring a target as ``.PHONY`` is good for performance, even if you
are not worried about the actual file existing.

Empty Target Files to Record Events
-----------------------------------------------------------------------

The empty target is a variant of the phony target; it is used to hold
recipes for an action that you request explicitly from time to time.
Unlike a phony target, this target file can really exist; but the file’s
contents do not matter, and usually are empty. The purpose is to record,
with its last-modification time, when the rule’s recipe was last
executed.

It does so because one of the commands in the recipe is a touch command
to update the target file.

The empty target file should have some prerequisites (otherwise it
doesn’t make sense). When you ask to remake the empty target, the recipe
is executed if any prerequisite is more recent than the target; in other
words, if a prerequisite has changed since the last time you remade the
target. Here is an example:

.. code:: make

    print: foo.c bar.c
        lpr -p $?
        touch print

With this rule, ``make print`` will execute the ``lpr`` command if
either source file has changed since the last ``make print``. The
automatic variable ``$?`` is used to print only those files that have
changed.

Special Built-in Target Names
-----------------------------------------------------------------------

Certain names have special meanings if they appear as targets.

**.PHONY**

The prerequisites of the special target ``.PHONY`` are considered to be
phony targets. When it is time to consider such a target, make will run
its recipe unconditionally, regardless of whether a file with that name
exists or what its last-modification time is.

**.SUFFIXES**

The prerequisites of the special target ``.SUFFIXES`` are the list of
suffixes to be used in checking for suffix rules.

**.DEFAULT**

The recipe specified for ``.DEFAULT`` is used for any target for which
no rules are found (either explicit rules or implicit rules). If a
``.DEFAULT`` recipe is specified, every file mentioned as a
prerequisite, but not as a target in a rule, will have that recipe
executed on its behalf.

**.PRECIOUS**

The targets which ``.PRECIOUS`` depends on are given the following
special treatment: if make is killed or interrupted during the execution
of their recipes, the target is not deleted. Also, if the target is an
intermediate file, it will not be deleted after it is no longer needed,
as is normally done.

Multiple Rules for One Target
-----------------------------------------------------------------------

One file can be the target of several rules. All the prerequisites
mentioned in all the rules are merged into one list of prerequisites for
the target. If the target is older than any prerequisite from any rule,
the recipe is executed.

There can only be one recipe to be executed for a file. If more than one
rule gives a recipe for the same file, make uses the last one given and
prints an error message. Occasionally it is useful to have the same
target invoke multiple recipes which are defined in different parts of
your makefile; you can use double-colon rules for this.

An extra rule with just prerequisites can be used to give a few extra
prerequisites to many files at once. For example, makefiles often have a
variable, such as objects, containing a list of all the compiler output
files in the system being made. An easy way to say that all of them must
be recompiled if ``config.h`` changes is to write the following:

.. code:: make

    objects = foo.o bar.o

    foo.o : defs.h
    bar.o : defs.h test.h
        $(objects) : config.h

This could be inserted or taken out without changing the rules that
really specify how to make the object files, making it a convenient form
to use if you wish to add the additional prerequisite intermittently.

Another wrinkle is that the additional prerequisites could be specified
with a variable that you set with a command line argument to make. For
example:

.. code:: make

    extradeps=
    $(objects) : $(extradeps)

means that the command ``make extradeps=foo.h`` will consider ``foo.h``
as a prerequisite of each object file, but plain ``make`` will not.

Static Pattern Rules
-----------------------------------------------------------------------

Static pattern rules are rules which specify multiple targets and
construct the prerequisite names for each target **based on the target
name**. They are more general than ordinary rules with multiple targets
because the targets do not have to have identical prerequisites. Their
prerequisites must be analogous, but not necessarily identical.

Syntax of Static Pattern Rules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here is the syntax of a static pattern rule:

.. code:: make

    targets ...: target-pattern: prereq-patterns ...
        recipe


The targets list specifies the targets that the rule applies to. The
targets can contain wildcard characters, just like the targets of
ordinary rules. The ``target-pattern`` and ``prereq-patterns`` say how
to compute the prerequisites of each target. Each target is matched
against the ``target-pattern`` to extract a part of the target name,
called the **stem**. This stem is substituted into each of the
``prereq-patterns`` to make the prerequisite names (one from each
``prereq-pattern``).

Each pattern normally contains the character ``%`` just once. When the
``target-pattern`` matches a target, the ``%`` can match any part of the
target name; this part is called the stem. The rest of the pattern must
match exactly. For example, the target ``foo.o`` matches the pattern
``%.o``, with ``foo`` as the stem. The targets ``foo.c`` and ``foo.out``
do not match that pattern.

The prerequisite names for each target are made by substituting the stem
for the ‘%’ in each prerequisite pattern. For example, if one
prerequisite pattern is ``%.c``, then substitution of the stem ``foo``
gives the prerequisite name ``foo.c``. It is legitimate to write a
prerequisite pattern that does not contain ``%``; then this prerequisite
is the same for all targets.

Here is an example, which compiles each of foo.o and bar.o from the
corresponding .c file:

.. code:: make

    objects = foo.o bar.o

    all: $(objects)

    $(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@

Here ``$<`` is the automatic variable that holds the name of the
prerequisite and ``$@`` is the automatic variable that holds the name of
the target.

Each target specified must match the target pattern; a warning is issued
for each target that does not. If you have a list of files, only some of
which will match the pattern, you can use the ``filter`` function to
remove non-matching file names:

.. code:: make

    files = foo.elc bar.o lose.o

    $(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $< -o $@

    $(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $<

Another example shows how to use ``$*`` in static pattern rules:

.. code:: make

    bigoutput littleoutput : %output : text.g
        generate text.g -$* > $@

When the generate command is run, ``$*`` will expand to the stem, either
``big`` or ``little``.
