---
title: Notes on Make
---

## About make

The make utility automatically determines which pieces of a large program need
to be recompiled, and issues commands to recompile them. You can use it to
describe any task where some files must be updated automatically from others
whenever the others change.

To prepare to use make, you must write a file called `Makefile` that describes the
relationships among files in your program and provides commands for updating each file.

The make program uses the makefile and the last-modification times of the files to decide which files need to be
updated. For each of those files, it issues the corresponding recipes.
You can provide command line arguments to make.

## Introduction to Makefiles

In this chapter, we will discuss a simple makefile that describes how to compile and link
a text editor which consists of eight C source files and three header files.

In this cases, we have to solve:

 - Each changed C source file must be recompiled.

 - If a header file has changed, each C source file that includes the header file must be recompiled
  to be safe. 

 - Each compilation produces an object file corresponding to the source file.

 - if any source file has been recompiled, all the object files, whether newly made or saved
  from previous compilations, must be linked together to produce the new executable.

### Rules

A simple makefile consists of **rules** with the following shape:

```make
target ... : prerequisites ...
    recipe
    ...
    ...
```

A **target** is usually the name of a file that is generated by a program;
examples of targets are executable or object files. A target can also be the
name of an action to carry out, such as `clean`.

A **prerequisite** is a file that is used as input to create the target. A
target often depends on several files.

A **recipe** is an action that make carries out. A recipe may have more than
one command, either on the same line or each on its own line.

Please note: you need to put a **tab character at the beginning** of every
recipe line! This is an obscurity that catches the unwary.

Usually a recipe is in a rule with prerequisites and serves to create a target
file if any of the prerequisites change. However, the rule that specifies a
recipe for the target need not have prerequisites. For example, the rule
containing the delete command associated with the target ‘clean’ does not have
prerequisites.

A rule, then, explains how and when to remake certain files which are the
targets of the particular rule. make carries out the recipe on the
prerequisites to create or update the target.

In this example, all the C files include `defs.h`, but only those defining editing commands
include `command.h`, and only low level files that change the editor buffer include `buffer.h`:

```make
edit : main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o

main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h command.h
    cc -c kbd.c
command.o : command.c defs.h command.h
    cc -c command.c
display.o : display.c defs.h buffer.h
    cc -c display.c
insert.o : insert.c defs.h buffer.h
    cc -c insert.c
search.o : search.c defs.h buffer.h
    cc -c search.c
files.o : files.c defs.h buffer.h command.h
    cc -c files.c
utils.o : utils.c defs.h
    cc -c utils.c
clean :
    rm edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
```

We split each long line into two lines using backslash.

In the example, the targets include the executable file `edit`, and the object
files `main.o` and `kbd.o`. The prerequisites are files such as `main.c` and
`defs.h`. In fact, each `.o` file is **both a target and a prerequisite**.
Recipes include `cc -c main.c` and `cc -c kbd.c`.

The target `clean` is not a file, but merely the name of an action. Since you
normally do not want to carry out the actions in this rule, `clean` is __not a
prerequisite__ of any other rule. Consequently, make never does anything with
it unless you tell it specifically. Note that this rule not only is not a
prerequisite, it also __does not have any prerequisites__, so the only purpose
of the rule is to run the specified recipe. Targets that do not refer to files
but are just actions are called **phony targets**.

### Variables Make Makefiles Simpler

In our example, we had to list all the object files twice in the rule for edit (repeated here):

```make
edit : main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o \
        insert.o search.o files.o utils.o
```

Such duplication is error-prone; if a new object file is added to the system,
we might add it to one list and forget the other. We can eliminate the risk and
simplify the makefile by using a variable. Variables allow a text string to be
defined once and substituted in multiple places later.

It is standard practice for every makefile to have a variable named objects,
OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object file names. We
would define such a variable objects with a line like this in the makefile:

```make
objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o
```

Then, each place we want to put a list of the object file names, we can
substitute the variable’s value by writing ‘$(objects)’ (see Chapter 6 [How to
Use Variables], page 59).  Here is how the complete simple makefile looks when
you use a variable for the object files:

```make
objects = main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o
edit : $(objects)
    cc -o edit $(objects)
```

### Letting make Deduce the Recipes

It is not necessary to spell out the recipes for compiling the individual C
source files, because make can figure them out: it has an implicit rule for
updating a `'.o'` file from a correspondingly named `'.c'` file using a `cc -c`
command. For example, it will use the recipe `cc -c main.c -o main.o` to
compile `main.c` into `main.o`. We can therefore omit the recipes from the
rules for the object files.

When a ‘.c’ file is used automatically in this way, it is also automatically
added to the list of prerequisites. We can therefore omit the ‘.c’ files from
the prerequisites, provided we omit the recipe.

Here is the entire example, with both of these changes, and a variable objects
as suggested above:

```make
objects = main.o kbd.o command.o display.o \
    insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean

clean :
    rm edit $(objects)
```

## Rules for Cleaning the Directory

Compiling a program is not the only thing you might want to write rules for.
Makefiles commonly tell how to do a few other things besides compiling a
program: for example, how to delete all the object files and executables so
that the directory is `clean`.  Here is how we could write a make rule for
cleaning our example editor:

```make
clean:
    rm edit $(objects)
```

In practice, we might want to write the rule in a somewhat more complicated
manner to handle unanticipated situations. We would do this:

```make
.PHONY : clean
clean :
    -rm edit $(objects)
```

The `.PHONY` declaration prevents make from getting confused by an actual file
called clean, and `-` prefix causes the command to continue in spite of errors
from rm.

A rule such as this should not be placed at the beginning of the makefile,
because we do not want it to run by default! Thus, in the example makefile, we
want the rule for `edit`, which recompiles the editor, to remain the default
goal.  Since clean is not a prerequisite of edit, this rule will not run at all
if we give the command `make` with no arguments. In order to make the rule run,
we have to type `make clean`.

A rule tells make two things: **when the targets are out of date**, and **how
to update them** when necessary:

- A target is out of date if it does not exist or if it is older than any of
  the prerequisites (by comparison of last-modification times).

- How to update is specified by a recipe. This is one or more lines to be
  executed by the shell

- (normally ‘sh’), but with some extra features.


## Types of Prerequisites

There are actually two different types of prerequisites understood by GNU make:
**normal prerequisites** such as described in the previous section, and
**order-only prerequisites**.

A normal prerequisite makes two statements: first, it imposes an order in which
recipes will be invoked: the recipes for all prerequisites of a target will be
completed before the recipe for the target is run. Second, it imposes a
dependency relationship: if any prerequisite is newer than the target, then the
target is considered out-of-date and must be rebuilt.

Normally, this is exactly what you want: if a target’s prerequisite is updated,
then the target should also be updated.

Occasionally, however, you have a situation where you want to impose a specific
ordering on the rules to be invoked without forcing the target to be updated if
one of those rules is executed. In that case, you want to define order-only
prerequisites. Order-only prerequisites can be specified by placing a pipe
symbol (|) in the prerequisites list: any prerequisites to the left of the pipe
symbol are normal; any prerequisites to the right are order-only:

```make
targets : normal-prerequisites | order-only-prerequisites
```

The normal prerequisites section may of course be empty. Also, you may still
declare multiple lines of prerequisites for the same target: they are appended
appropriately (normal prerequisites are appended to the list of normal
prerequisites; order-only prerequisites are appended to the list of order-only
prerequisites). Note that if you declare the same file to be both a normal and
an order-only prerequisite, the normal prerequisite takes precedence (since
they have a strict superset of the behavior of an order-only prerequisite).

Consider an example where your targets are to be placed in a separate
directory, and that directory might not exist before make is run. In this
situation, you want the directory to be created before any targets are placed
into it but, because the timestamps on directories change whenever a file is
added, removed, or renamed, we certainly don’t want to rebuild all the targets
whenever the directory’s timestamp changes. One way to manage this is with
order-only prerequisites: make the directory an order-only prerequisite on all
the targets:

```make
OBJDIR := objdir
OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)
$(OBJDIR)/%.o : %.c
    $(COMPILE.c) $(OUTPUT_OPTION) $<

all: $(OBJS)
$(OBJS): | $(OBJDIR)
$(OBJDIR):
    mkdir $(OBJDIR)
```

Now the rule to create the objdir directory will be run, if needed, before any `.o` is
built, but no `.o` will be built because the objdir directory timestamp changed.

## Using Wildcard Characters in File Names

A single file name can specify many files using wildcard characters. The
wildcard characters in make are `*`, `?` and `[...]`, the same as in the Bourne
shell. For example, `*.c` specifies a list of all the files (in the working
directory) whose names end in `.c`.

The character `~` at the beginning of a file name also has special
significance. If alone, or followed by a slash, it represents your home
directory.

Wildcard expansion is performed by make automatically in targets and in
prerequisites.  In recipes, the shell is responsible for wildcard expansion. In
other contexts, wildcard expansion happens only if you request it explicitly
with the wildcard function.

The special significance of a wildcard character can be turned off by preceding
it with a backslash. Thus, `foo\*bar` would refer to a specific file whose name
consists of ‘foo’, an asterisk, and ‘bar’.

For example, here is a rule to delete all the object files:

```make
clean:
    rm -f *.o
```

Wildcards are also useful in the prerequisites of a rule. With the following
rule in the makefile, ‘make print’ will print all the ‘.c’ files that have
changed since the last time you printed them:

```python
print: *.c
    lpr -p $?
    touch print
```

This rule uses print as an **empty target file**; (The automatic variable ‘$?’
is used to print only those files that have changed.

Wildcard expansion does not happen when you define a variable. Thus, if you
write this:

```make
objects = *.o
```

then the value of the variable objects is the actual string `*.o`. However, if
you use the value of objects in a target or prerequisite, wildcard expansion
will take place there.

If you use the value of objects in a recipe, the shell may perform wildcard
expansion when the recipe runs. To set objects to the expansion, instead use:

```make
objects := $(wildcard *.o)
```

## The Function wildcard

Wildcard expansion happens automatically in rules. But wildcard expansion does
not normally take place when a variable is set, or inside the arguments of a
function. If you want to do wildcard expansion in such places, you need to use
the wildcard function, like this:

```python
$(wildcard pattern...)
```

the value of `$^` is a list of all the prerequisites of the rule, including the
names of the directories in which they were found, and the value of `$@` is the
target.

Often the prerequisites include header files as well, which you do not want to mention
in the recipe. The automatic variable `$&lt;` is just the first prerequisite:

    VPATH = src:../headers
    foo.o : foo.c defs.h hack.h
        cc -c $(CFLAGS) $&lt; -o $@

## Phony Targets

A **phony target** is one that is not really the name of a file; rather it is
just a name for a recipe to be executed when you make an explicit request.
There are two reasons to use a phony target: to avoid a conflict with a file of
the same name, and to improve performance.

If you write a rule whose recipe will not create the target file, the recipe
will be executed every time the target comes up for remaking. Here is an
example:

```make
clean:
    rm *.o temp
```

Because the `rm` command does not create a file named `clean`, probably no such
file will ever exist. Therefore, the `rm` command will be executed every time
you say `make clean`.  In this example, the clean target will not work properly
if a file named `clean` is ever created in this directory. Since it has no
prerequisites, clean would always be considered up to date and its recipe would
not be executed. To avoid this problem you can explicitly declare the target to
be phony by making it a prerequisite of the special target `.PHONY` as follows:

```make
.PHONY: clean
clean:
    rm *.o temp
```

Once this is done, `make clean` will run the recipe regardless of whether there
is a file named clean.

The implicit rule search is skipped for `.PHONY` targets. This is why declaring a
target as `.PHONY` is good for performance, even if you are not worried about the
actual file existing.


## Empty Target Files to Record Events

The empty target is a variant of the phony target; it is used to hold recipes
for an action that you request explicitly from time to time. Unlike a phony
target, this target file can really exist; but the file’s contents do not
matter, and usually are empty. The purpose is to record, with its
last-modification time, when the rule’s recipe was last executed.

It does so because one of the commands in the recipe is a touch command to
update the target file.

The empty target file should have some prerequisites (otherwise it doesn’t make
sense).  When you ask to remake the empty target, the recipe is executed if any
prerequisite is more recent than the target; in other words, if a prerequisite
has changed since the last time you remade the target. Here is an example:

```make
print: foo.c bar.c
    lpr -p $?
    touch print
```

With this rule, `make print` will execute the `lpr` command if either source
file has changed since the last `make print`. The automatic variable `$?` is
used to print only those files that have changed.


## Special Built-in Target Names

Certain names have special meanings if they appear as targets.

**.PHONY**

The prerequisites of the special target `.PHONY` are considered to be phony
targets.  When it is time to consider such a target, make will run its recipe
unconditionally, regardless of whether a file with that name exists or what its
last-modification time is. 

**.SUFFIXES**

The prerequisites of the special target `.SUFFIXES` are the list of suffixes to
be used in checking for suffix rules.

**.DEFAULT**

The recipe specified for `.DEFAULT` is used for any target for which no rules
are found (either explicit rules or implicit rules). If a `.DEFAULT` recipe is
specified, every file mentioned as a prerequisite, but not as a target in a
rule, will have that recipe executed on its behalf.

**.PRECIOUS**

The targets which `.PRECIOUS` depends on are given the following special
treatment: if make is killed or interrupted during the execution of their
recipes, the target is not deleted.  Also, if the target is an intermediate
file, it will not be deleted after it is no longer needed, as is normally done.

## Multiple Rules for One Target

One file can be the target of several rules. All the prerequisites mentioned in
all the rules are merged into one list of prerequisites for the target. If the
target is older than any prerequisite from any rule, the recipe is executed.

There can only be one recipe to be executed for a file. If more than one rule
gives a recipe for the same file, make uses the last one given and prints an
error message. Occasionally it is useful to have the same target invoke
multiple recipes which are defined in different parts of your makefile; you can
use double-colon rules for this.

An extra rule with just prerequisites can be used to give a few extra
prerequisites to many files at once. For example, makefiles often have a
variable, such as objects, containing a list of all the compiler output files
in the system being made. An easy way to say that all of them must be
recompiled if `config.h` changes is to write the following:

```make
objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h
```

This could be inserted or taken out without changing the rules that really
specify how to make the object files, making it a convenient form to use if you
wish to add the additional prerequisite intermittently.

Another wrinkle is that the additional prerequisites could be specified with a
variable that you set with a command line argument to make. For example:

```make
extradeps=
$(objects) : $(extradeps)
```

means that the command `make extradeps=foo.h` will consider `foo.h` as a
prerequisite of each object file, but plain `make` will not.

## Static Pattern Rules

Static pattern rules are rules which specify multiple targets and construct the
prerequisite names for each target **based on the target name**. They are more
general than ordinary rules with multiple targets because the targets do not
have to have identical prerequisites. Their prerequisites must be analogous,
but not necessarily identical.

### Syntax of Static Pattern Rules

Here is the syntax of a static pattern rule:

```make
targets ...: target-pattern: prereq-patterns ...
    recipe
    ...
```

The targets list specifies the targets that the rule applies to. The targets
can contain wildcard characters, just like the targets of ordinary rules.  The
`target-pattern` and `prereq-patterns` say how to compute the prerequisites of
each target. Each target is matched against the `target-pattern` to extract a
part of the target name, called the **stem**. This stem is substituted into
each of the `prereq-patterns` to make the prerequisite names (one from each
`prereq-pattern`).

Each pattern normally contains the character `%` just once. When the
`target-pattern` matches a target, the `%` can match any part of the target
name; this part is called the stem. The rest of the pattern must match exactly.
For example, the target `foo.o` matches the pattern `%.o`, with `foo` as the
stem. The targets `foo.c` and `foo.out` do not match that pattern.

The prerequisite names for each target are made by substituting the stem for
the ‘%’ in each prerequisite pattern. For example, if one prerequisite pattern
is `%.c`, then substitution of the stem `foo` gives the prerequisite name
`foo.c`. It is legitimate to write a prerequisite pattern that does not contain
`%`; then this prerequisite is the same for all targets.

Here is an example, which compiles each of foo.o and bar.o from the
corresponding .c file:

```make
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
```

Here `$<` is the automatic variable that holds the name of the prerequisite and
`$@` is the automatic variable that holds the name of the target.

Each target specified must match the target pattern; a warning is issued for
each target that does not. If you have a list of files, only some of which will
match the pattern, you can use the `filter` function to remove non-matching
file names:

```make
files = foo.elc bar.o lose.o
$(filter %.o,$(files)): %.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
$(filter %.elc,$(files)): %.elc: %.el
    emacs -f batch-byte-compile $<
```

Another example shows how to use `$*` in static pattern rules:

```make
bigoutput littleoutput : %output : text.g
    generate text.g -$* > $@
```

When the generate command is run, `$*` will expand to the stem, either `big` or
`little`.
