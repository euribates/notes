---
title: Notas sobre Keycloak
---

## Sobre Keycloak


## Definiciones

- **Identification**

Identification happens when a user claims an identity. In the physical world,
we could state our name. When I meet somebody for the first time, I introduce
myself by saying “I’m Thomas”: that is me identifying myself.

In the digital world, instead, I would provide my username or email address,
claiming the identity of my account, for example.

Identification is the first step of access control.

- **Authentication**

If I went to the airport to catch a flight and told the airport personnel “I’m
Thomas”, for sure, they would ask me for some proof of my identity. That is the
authentication process: verifying a claimed identity.

At the airport, I would prove my identity through my passport. When trying to
get into my email account, I would provide my password to prove that I am who
I’m claiming to be and that one is really my account. In case I had enabled a
2-factor authentication (and I should), I would also provide a second proof of
my identity, for example, a code generated by a USB token or a dedicated app on
my smartphone.

Verifying the user identity, i.e. authenticating them, is the second step of
access control.

- **Authorization**

Once the airport personnel has authenticated my identity through my passport,
that means they have proved my identity, but that doesn’t mean I can go
wherever I want across the airport or catch whichever flight. Nope. I can only
do what I have permissions for, i.e. what I’m authorized to do. Buying a ticket
to Reykjavík grants me the right to fly to Iceland, as long as I identify
myself as the owner of the ticket and prove my identity. (I know, I have
simplified security airport procedures a lot, but it was for the sake of the
example.)

If we consider the email account example again, after the authentication phase,
the email provider will check for my permissions to figure out what I can or
cannot do once got access to my email account. A necessary permission is the
one granting me access to my, and only my, emails — not the ones from other
email accounts. In a CMS application, I might have permissions to add new
content, but not delete it. An administrator would have permissions to perform
more operations than me.

Authorization is the third step of access control.

## Authentication Flows

The starting point in our process to secure an application or a web service
with Keycloak is to identify and authenticate the user. The sequence of actions
a user or a service needs to perform to be authenticated, in Keycloak, is
called **authentication flow**.

Keycloak provides already several authentication flows that you can customise
in `Authentication -> Flows`. Should you need something different, you can always
create your own by choosing New in the far right of the screen.

## SSO Protocols

Communication between Keycloak and the clients asking it for authentication
services happens according to one of the two main supported SSO (Single
Sign-On) protocols: OpenID Connect and SAML.

- **OpenID Connect (OIDC)** is the preferred method. It's a modern protocol
  built on top of the OAuth 2.0 framework.

- **SAML** is an older authentication protocol, which gained popularity in the
  world of SOAP services. It relies on XML documents containing assertions
  about the user, while OIDC makes use of JWT (JSON Web Token) in the form of
  identity tokens and access tokens.

Formalising the concepts standardised by the OAuth 2.0 framework, OIDC defines
**four** main flows that can be used to authenticate a user:

- **Authorization Code Flow** for browser-based applications like SPAs (Single
  Page Applications) or server-side application;

- **Implicit Flow** for browser-based application, less secure than the
  previous one, not recommended and deprecated in OAuth 2.1;

- **Client Credentials Grant** for REST clients like web services, it involves
  storing a secret, so the client is supposed to be trustworthy;

- **Resource Owner Password Credentials Grant** for REST clients like
  interfaces to mainframes and other legacy systems which cannot support modern
  authentication protocols, it involves sharing credentials with another
  service, caution here.

It is important to note that access tokens are usually **short lived** and often
expired after only minutes. The additional refresh token that was transmitted
by the login protocol allows the application to obtain a new access token after
it expires. This refresh protocol is important in the situation of a
compromised system. If access tokens are short lived, the whole system is only
vulnerable to a stolen token for the lifetime of the access token. **Future
refresh token requests will fail if an admin has revoked access**. This makes
things more secure and more scalable.

Another important aspect of this flow is the concept of a **public** vs. a
**confidential** client. Confidential clients are required to provide a client
secret when they exchange the temporary codes for tokens. Public clients are
not required to provide this client secret. Public clients are perfectly fine
so long as HTTPS is strictly enforced and you are very strict about what
redirect URIs are registered for the client. **HTML5/JavaScript clients always
have to be public clients because there is no way to transmit the client secret
to them in a secure manner**. Again, this is ok so long as you use HTTPS and
strictly enforce redirect URI registration. This guide goes more detail into
this in the Managing Clients chapter.

## Keycloak’s core concepts

A Keycloak **realm** is like a namespace that allows you to manage all of your
metadata and configurations. You can have multiple realms based on your
requirements. Generally, it is recommended to avoid using the ``master`` realm,
which is for administration purposes only.

you can see the information that Keycloak lets you manage, namely:

- Clients (per application)
- Configuration management
- Custom themes (UI)
- Events
- Federation
- LDAP or Active Directory integration
- User management (users and groups)

Keycloak supports the following standard protocols: OAuth 2.0, OpenID Connect
and SAML 2.0. This support means that any tool or application that supports
integration with the above protocols can be plugged into with Keycloak


## Preparing to integrate with Keycloak

Once you’re ready to integrate your apps, tools, and services with Keycloak,
you have decisions to make:

1) You need to decide which protocol you intend to use, such as:

  - OAuth2
  - OpenID Connect
  - Security Assertion Markup Language (SAML).

2) Are you looking for authentication or authorization?

  OAuth 2 != Authentication, only Authorization 

  OpenID Connect = Identity + Authentication + Authorization

3) regarding the application:

  Is it running on a container (stateless) or is it in a legacy clustered
  (shared state) environment?  What does the architecture consist of, such as
  single-page applications (SPA), microservices, serverless, or MVC?  Identify
  the resources and endpoints you want to secure. Is your integration between,
  for example, client and server, service-to-service, or API endpoints.
  Identify which adapter will be suited for your architecture.

Para ejecutar en docker::

```
docker run -p 8080:8080 -e KEYCLOAK_USER=root -e KEYCLOAK_PASSWORD=iamroot jboss/keycloa:latest
```


## Más información

Sobre oAuth y openId:

- https://www.thomasvitale.com/keycloak-configuration-authentication-authorisation/
- https://files.gotocon.com/uploads/slides/conference_12/653/original/20181101%20-%20Introduction%20to%20OAuth%202.0%20and%20OpenID%20Connect.pdf
- [Keycloak Deep dive](https://www.youtube.com/watch?v=XJYy6Aq-PJ8)
- [API Endpoints for Single Sign-On](https://auth0.com/docs/sso/api-endpoints-for-single-sign-on)



## Securing Apps

### 1. Overview

Keycloak supports both OpenID Connect (an extension to OAuth 2.0) and SAML 2.0.
When securing clients and services the first thing you need to decide is which
of the two you are going to use. If you want you can also choose to secure some
with OpenID Connect and others with SAML.

To secure clients and services you are also going to need an adapter or library
for the protocol you’ve selected. Keycloak comes with its own adapters for
selected platforms, but it is also possible to use generic OpenID Connect
Resource Provider and SAML Service Provider libraries.

### What are Client Adapters?

Keycloak client adapters are libraries that makes it very easy to secure
applications and services with Keycloak. We call them adapters rather than
libraries as they provide a tight integration to the underlying platform and
framework. This makes our adapters easy to use and they require less
boilerplate code than what is typically required by a library.

### 1.3. Supported Protocols

**OpenID Connect (OIDC)** is an authentication protocol that is an extension of
OAuth 2.0. While OAuth 2.0 is only a framework for building authorization
protocols and is mainly incomplete, OIDC is a full-fledged authentication and
authorization protocol. OIDC also makes heavy use of the Json Web Token (JWT)
set of standards. These standards define an identity token JSON format and ways
to digitally sign and encrypt that data in a compact and web-friendly way.

There are really **two types of use cases** when using OIDC. The first is an
application that asks the Keycloak server to authenticate a user for them.
After a successful login, the application will receive an identity token and an
access token. The identity token contains information about the user such as
username, email, and other profile information. The access token is digitally
signed by the realm and contains access information (like user role mappings)
that the application can use to determine what resources the user is allowed to
access on the application.

The second type of use cases is that of a client that wants to gain access to
remote services. In this case, the client asks Keycloak to obtain an access
token it can use to invoke on other remote services on behalf of the user.
Keycloak authenticates the user then asks the user for consent to grant access
to the client requesting it. The client then receives the access token. This
access token is digitally signed by the realm. The client can make REST
invocations on remote services using this access token. The REST service
extracts the access token, verifies the signature of the token, then decides
based on access information within the token whether or not to process the
request.


